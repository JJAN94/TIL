1. 시퀀스 자료형 (dict)의 특징, 활용을 구현해보자
2. 표준 입출력을 구현하고 활용하자
3. 제어문의 종류를 이해하고 숙지할 수 있다.
4. 함수를 선언하고 활용할 수 있다.

---

### 파이썬을 배우고 나서?

-> 모듈(클래스, 상속, 다형성 + 함수)을 자유롭게 만들 수 있다. 모듈 실행 가능
-> 정형 <-> 비정형 을 오가며 다룰 수 있다.
-> 파일처리

----

### 내장함수란?

​	클래스를 객체생성을 자동으로 구현한 다음 함수처럼 사용할 수 있게 제공되는 것
​	len(object) : 요소의 길이를 리턴한 함수
​	print() , 리터럴을 저장할 때 자동으로 생성되는 객체들
​	help(), dir()
​	del : 생성된 객체를 소멸할 때 사용하는 키워드(클래스 내의 소멸자 자동호출)



str, tuple, list(값변경 가능), dict, set



### dict(딕셔너리 : Dictionary) 

자료를 대입할 때 {}안에 콤마로 값을 분류하고 key : value 형태로 선언하는 구조를 가져 비정형 데이터를 매핑할 때 유용하게 사용된다.



비정형 데이터 : .xml, .csv, .tsv, .json, .sql(정형+비정형)



데이터 처리 변환 : dict -> .json or .txt -> 비정형 서버

​	ex) 음악파일 -> 수치 -> dict(.json) -> 벡터 -> 분석 등

​	ex) 이미지 -> RGB(255.0.0) -> 벡터(적재, 분류) -> 분석



dict 특징

1. 정렬되지 않은 key - value pair이다.
2. 새로운 키를 입력할 때는 반드시 key에 해당하는 value도 함께 입력해야 한다.
3. value값은 변경 가능하지만 key값은 변경 불가능
4. key를 호출하면 value를 리턴하는 구조를 가진다.



dict class의 메서드 -> help(dict), dir(dict) 해당 클래스가 가진 멤버들 확인

my = {'a1' = 1234, 'b1' = 'abc'}         **CRUD 메서드는 꼭 찾아보자(중요함)**

1. dict.keys() : key들을 모아놓은 리스트를 리턴 dict_keys(['a1', 'b1'])
2. my.values() : value들을 모아놓은 리스트를 리턴 dict_values([1234, 'abc'])
3. my.items() : key, value를 튜플로 변환해 리스트로 리턴 dict_items([('a1', 1234), ('b1', 'abc')])
4. my.clear() : 모든 내용을 삭제, 빈 {}로 리턴
5. my.get(key) : 지정된 key값을 주면 values를 리턴
6. update() : my['a1']='9999' 값 변경 
7. del my['a'] : 'a' key에 해당하는 key와 value를 딕셔너리에서 삭제한다.





### 예제)

| 속성(key) | 값        |
| --------- | --------- |
| id        | Dominica  |
| pw        | admin1234 |
| db        | Oracle    |

my_dict = {'id' : 'Dominica', 'pw' : 'admin1234', 'db' : 'Oracle'}

dir(dict)

속성과 값을 가진 데이터가 있다.

1) my_dict라는 dict 변수( 인스턴스변수)에 값을 입력한다
2) 전체 출력
3) 키로 값만 출력 ex) my['a1']
4) 키만 출력
5) 값만 출력
6) pw를 1234로 변경
7) 아이템 전체 삭제 후  {}로 남겨준다

```python
# 1)
my_dict = {'id' : 'Dominica', 'pw' : 'admin1234', 'db' : 'Oracle'}
# 2)
my_dict
# 3)
my_dict['id'], my_dict['pw'], my_dict['db'] # 또는
my_dict.get('id'), my_dict.get('pw'), my_dict.get('db')
# 4)
my_dict.keys()
# 5)
my_dict.values()
# 6)
my_dict['pw'] = 1234
# 7)
my_dict.clear()
```

---

set : 파이썬에서 {}안에서 저장된 자료를 집합연산을 통해 자료를 추출하고 싶을 때 사용하는 자료형

```python
set('aaaaaaa') # {'a'}
set('aaa aa aaaaa') # {'a', ' '}
set('aaa a aaaa None aa') # {'e', 'a', ' ', 'N', 'o', 'n'}
set('aaa aa aa None a \\ \n \\\\\ %%%%') # {'e', 'a', ' ', 'N', '%', '\n', '\\', 'o', 'n'}
```

특징

1. 중복을 무시한다. (중복되지 않은 요소들의 모임을 가진 집합으로 임의의 순서를 가진다.)
2. 임의의 순서로 리턴한다.
3. 공집합은 {}가 아닌 set()로 호출된다.
4. set(element)로 넣지만 {element}로 리턴한다.
5. 선언은 set()의 ()안에 자료를 입력하거나 tuple(), list[]로 데이터를 입력할 수 있다.
6. 집합 연산 : 차집합, 교집합, 합집합, 대칭차집합(symmetric difference)연산을 할 수 있다.
   - 대칭차집합 : 둘의 합집합에서 교집합을 뺀 차집합
7. 이스케이프문자 (ex : \n)은 하나의 문자로 본다. \는 중복(짝수개로 넣어야한다)한다. (ex : \\\\\\\\\\\은 \\\로 나온다) %는 중복하지 않는다.
8. set()안에 dict를 넣으면 key값만 들어간다.

```python
# 집합연산
A = set([1,2,3,4])
B = set([2,4,6])
A.union(B) # 합집합 
A | B # 합집합

A.intersection(B) # 차집합
A & B # 교집합

A.difference(B) # 차집합 A-B
A - B # 차집합
```

<img src="C:\Users\JAY\Desktop\플레이데이터\데일리파일\set의method.png" style="zoom: 67%;" />



---

2. 표준입출력을 구현하고 활용
   - 표준입출력이란?
     - 처리하고 하는 자료의 값을 프로그램이 기본적으로 제공하는 장치를 이용하여 입력과 출력을 구현하는 것
     - 표준 입출력은 콘솔장치를 이용하게 된다.
     - 즉, 파이썬의 쉘을 이용해서 입출력 하는 부분과 데이터베이스를 포함한 파일의 저장된 자료를 입출력하는 부분으로 관리된다.
     - 파이썬에서는 python shell창에 출력하는 기능을 표준 출력 standard output이라고 하고 print()함수가 수행한다.
     
   - print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
     - value : 출력될 값
     - sep : 연속적인 값을 하나의 공백으로 구분한다. 다른 문자열을 대입해서 사용할 수 있다.
     - end : 기본은 '\n' (줄바꿈)
     - file : sys모듈(장치관리자), 출력스트림, 즉 콘솔로 출력하도록 되어 있으며 대상을 지정하여 출력 장치를 변경할 수 있다. ex) sys.stderr 또는 파일로 출력 대상을 보낼 수 있다.
     - flush : 출력 버퍼를 지워버리거나 값을 파일에 쓰고 난 뒤 버퍼를 지워버리는 기능을 한다.
       - 키보드 글자 -> 프로그램이 파일을 열어놓은 상태 -> 파일을 닫는 명령
       - io.DEFAULT_BUFFER_SIZE
     
   - format 서식(format string)
     
     - '\[flags]\[width]\[.precision]type'%(value) : 포맷서식 : 포밋팅을 이용하여 출력할 자료형 또는 자리수를 지정
     
     - flags : %로 지정, 포매팅 시작하겠다.
     
     - width : value의 자릿수
     
     - precision : 소수이하 자리수 지정
     
     - type : 출력될 value의 데이터 형
     
       - %d : 10진수(%i랑 같음, 파이썬에만 i가 있음, 대도록이면 쓰지말자)
       - %o : 8진수(=%O)
       - %x : 16진수(=%X)
       - %e : 지수
       - %f : 실수(=%F)
       - %g : 정밀도기준(=%G)
       - %c : 단일문자
       - %r : 문자열 repr()의 결과값 출력
       - %s : 문자열
       - %% : %를 출력
     
       '\[flags]-\[width]\[.precision]type'%(value) : -를 쓰면 왼쪽 정렬
     
   - str이 가진 format() 함수 사용 (=C#)
   
     - S.format(*args, **kwargs) : 문자열에서 맵핑되는 자료형을 전체 자릿수에 맞추어 정렬할 수 있고 인덱스를 통해서 출력할 수 있는 값의 위치를 지정한다.
     - < > ^ : 왼쪽, 오른쪽, 가운데 정렬



참고)

1. 임시기억장소

   1. 버퍼 : (byte단위로 처리되는 대상에 존재하는 임시기억장치)

      - 버퍼는 속도 차이가 있는 [하드웨어](http://www.terms.co.kr/hardware.htm) 장치들, 또는 우선 순위가 다른 프로그램의 [프로세스](http://www.terms.co.kr/process.htm)들에 의해 공유되는 [데이터](http://www.terms.co.kr/data.htm) 저장소를 말한다. 버퍼는 각 장치나 프로세스가 상대방에 의해 정체되지 않고 잘 동작할 수 있도록 해준다. 효율적인 버퍼를 만들기 위해서는, 버퍼의 크기를 상황에 맞게 잘 설계하고, 데이터를 버퍼로 집어넣거나 빼내기 쉽도록 우수한 [알고리즘](http://www.terms.co.kr/algorithm.htm)을 개발하는 것이 중요하다.

        "데이터의 중간 저장소"라는 측면에서 버퍼는 [캐시](http://www.terms.co.kr/cache.htm)와 마찬가지이지만, 캐시가 어떤 작업의 속도를 증진시키기 위해 존재하는데 비해, 버퍼는 개별 작업들 간의 협동을 지원하기 위해 존재한다는 차이가 있다.

        이 용어는 프로그래밍과 [하드웨어](http://www.terms.co.kr/hardware.htm) 분야 모두에 사용될 수 있다.

   2. 누산기(accumulator) : (1+2+3)

      - 누산기는 [CPU](http://www.terms.co.kr/CPU.htm) 내에서 계산의 중간 결과를 저장하는 [레지스터](http://www.terms.co.kr/register.htm)를 가리킨다. 만약 누산기가 없다면, 덧셈이나 곱셈 및 자리이동 등과 같은 각 계산의 결과를 주기억장치에 기록할 수밖에 없으며, 필요한 경우 그것들을 다시 읽어와야 한다. 누산기는 [ALU](http://www.terms.co.kr/ALU.htm)로 직접 통하는 통로를 가지고 있기 때문에, 주기억장치에 읽고 쓰는 것보다 훨씬 빠르다.

        누산기는 처음에는 0으로 설정되며, 각 숫자는 차례로 누산기 내에 있는 값에 더해진다. 그리고 모든 숫자들이 다 더해졌을 때에만, 그 결과가 주기억장치에 기록된다.

        현대식 CPU들은 대체로 많은 수의 레지스터들을 가지고 있는데, 그중 전부 또는 많은 수의 레지스터들이 누산기로 사용될 수 있다. 그렇기 때문에, 누산기는 다소 오래된 냄새가 나는 용어이다. 누산기를 레지스터와 동의어로 사용하는 것은, 그 사용자가 꽤 오랫동안 이 분야에서 활약했다는 확실한 지표이며, 논의 중인 [아키텍처](http://www.terms.co.kr/architecture.htm)도 상당히 해묵은 것이다. 비록 [마이크로프로세서](http://www.terms.co.kr/microprocessor.htm)의 산술 레지스터 심벌 이름이 "A"로 시작되는 것이, 누산기(accumulator)라는 용어에 기원을 두고 있다고 해도, 이 용어는 마이크로프로세서 레지스터들에는 거의 사용되지 않는다. 혼란스럽게도, 특히 모토롤라 680x0 계열과 같은 경우에는, 레지스터 이름의 접두사인 "A"가 "accumulator"가 아닌 "address"를 줄인 말로부터 나왔을 수도 있다.

   3. 클립보드 : (GUI 툴에서 복사, 잘라내기, 캡처, ctrl+c, ctrl+v...)

      - 클립보드는 하나의 [프로그램](http://www.terms.co.kr/program.htm)에서 다른 프로그램으로 [데이터](http://www.terms.co.kr/data.htm)를 복사하거나 붙여넣기할 때 임시 저장공간으로 사용되기 위해 확보되어 있는 [메모리](http://www.terms.co.kr/memory.htm) 영역이다. 마이크로소프트 윈도우나 애플 [매킨토시](http://www.terms.co.kr/Macintosh.htm)와 같은 [운영체계](http://www.terms.co.kr/OS.htm) 하에서, 클립보드는 하나의 프로그램에서 다른 곳으로 데이터를 복사하는데 사용될 수 있다. 워드프로세서나 엑셀 등 많은 윈도우용 응용프로그램에서 잘라내기, 복사, 또는 붙여넣기 등을 하기위해 클립보드가 사용된다.

        한 응용프로그램에서 데이터를 복사하거나 잘라내기 하고 나면 클립보드 표시기 등을 통해 그 내용을 볼 수 있다. 또한, 데이터를 잘라낸 다음, 그것을 다른 곳에 붙여넣기 하거나, 클립보드의 내용을 [파일](http://www.terms.co.kr/file.htm)로 저장하지 않은채, 컴퓨터를 종료하면, 그 데이터는 영원히 사라져 복구할 수 없게된다.

        매킨토시는 두 가지 형태의 클립보드를 사용한다. 하나는 클립보드라고 불리는 것인데, 이는 한번에 오직 한가지 항목만을 저장할 수 있고, 컴퓨터를 끄면 그 내용이 사라진다. 다른 하나는 스크랩북이라고 불리는데, 한번에 여러 개의 항목을 저장할 수 있으며 저장된 내용은 하나의 세션에서 다른 세션으로 계속해서 유지된다.

   4. 레지스터(register) : (명령어 임시저장)

      - 컴퓨터에서 레지스터는 [마이크로프로세서](http://www.terms.co.kr/microprocessor.htm)의 일부분으로서 아주 적은 [데이터](http://www.terms.co.kr/data.htm)를 잠시 저장할 수 있는 공간이며, 하나의 명령어에서 다른 명령어 또는 [운영체계](http://www.terms.co.kr/OS.htm)가 제어권을 넘긴 다른 [프로그램](http://www.terms.co.kr/program.htm)으로 데이터를 전달하기 위한 장소를 제공한다.

        하나의 레지스터는 하나의 [명령어](http://www.terms.co.kr/instruction.htm)를 저장하기에 충분히 커야하는데, 예를 들어 32 [비트](http://www.terms.co.kr/bit.htm) 명령어 컴퓨터에 사용되는 레지스터의 길이는 32 비트 이상이어야 한다. 그러나 어떤 종류의 컴퓨터에서는 길이가 짧은 명령어를 위해, 하프 레지스터라고 불리는 크기가 더 작은 레지스터를 쓰기도 한다.

        [프로세서](http://www.terms.co.kr/processor.htm) 설계나 언어규칙에 따라 차이가 있지만, 레지스터에는 대개 번호가 붙어있거나 또는 나름대로의 이름을 가지고 있다.























