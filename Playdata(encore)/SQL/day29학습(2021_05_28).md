Day29

1. 제약 조건에 대해 살펴보고 컬럼 레벨과 테이블 레벨을 통해 구현할 수 있다.
2. 제약 조건을 수정하고 삭제할 수 있다.
3. 제약 조건의 정보를 확인 할 수 있다.

---

#### 제약조건

- not null
  - 해당 컬럼에 null을 포함하지 않도록 선언 (컬럼)
- unique
  - 해당 컬럼 또는 컬럼 조합값이 유일하도록 함 (컬럼, 테이블)
- primary key
  - 식별 값 (컬럼, 테이블)
- references table(column)
  - 해달 컬럼이 참조하고 있는 (부모) 테이블의 특정 컬럼값들과 일치하거나 또는 null이 되도록 보장한다. (컬럼, 테이블)
- check
  - 해당 컬럼에 특정 조건에 만족 시키도록 한다. (컬럼, 테이블)



primary key = unique + not null





```sql
-- 제약 조건 확인
DESC USER_CONSTRAINTS;
CONSTRAINT_NAME : 제약 조건 이름
CONSTRAINT_TYPE : 유형 P(primary key), u(unique), r(reference), c(check)

TABLE_NAME
SEARCH_CONDITION : check 제약조건 내용
R_CONSTRAINT_NAME : 참조 테이블의 primary key 이름
DELETE_RULE : 참조 테이블의 PRIMARY KEY 컬럼이 삭제 될 때 사용되는 규칙
			(NO ACTION, SET NULL, CASCADE 등)
```



```sql
-- 삭제 룰
ON DELETE CASCADE : 대상 데이터를 삭제하고, 해당 데이터를 참조하는 데이터도 삭제
ON DELETE SET NULL : 대상 데이터를 삭제하고, 해당 데이터를 참조하는 데이터는 NULL로 바꿈
ON DELETE RESTRICTED : 삭제 대상 데이터를 참조하는 데이터가 존재하면 삭제할 수 없다 (기본값)


-- 수정 룰
ON UPDATE CASCADE : 대상 데이터를 수정하면 해당 데이터를 참조하는 데이터도 수정
```





EMP 테이블의 테이블 이름, 제약 조건, 타입을 확인해보자.

```sql
SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP';

SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT';
```



테이블 생성

```sql
CREATE TABLE 테이블명(
컬럼명1 데이터 타입 [제약조건],,,
);
```



테이블 수정

```sql
ALTER TABLE 테이블명
ADD 컬럼명 데이터타입[제약조건]
ADD CONSTRAINT 제약조건명 제약조건(컬럼명)
MODIFY 컬럼명 데이터타입
DROP COLUMN 컬럼명 [CASCADE CONSTRAINTS]
DROP PRIMARY KEY [CASCADE] | UNION(컬럼명...) [CASCADE]... | CONSTRAINT 제약조건명[CASCADE]...
```



이름변경

```sql
ALTER TABLE 기본테이블명 RENAME TO 새테이블명
RENAME 기존테이블명 TO 새테이블명

ALTER TABLE 테이블명 RENAME COLUMN 기본컬럼명 TO 새컬럼명
ALTER TABLE 테이블명 RENAME CONSTRAINT 기존제약조건명 TO 새제약조건명
```



테이블 복사

- 서브 쿼리를 이용한 테이블 생성 및 행(레코드) 복사

- 서브 쿼리를 이용해서 복사한 경우 NOT NULL을 제외한 제약조건은 복사 안됨

  (not null 제약조건도 SYS_\****으로 복사된다.)

```sql
CREATE TABLE 테이블명[컬럼명,,, ] AS 서브쿼리

CREATE TABLE 테이블명 1 AS SELECT * FROM 테이블명 WHERE 1=0;
```

---

Q1) 테이블 생성해보자

```sql
CREATE TABLE TEST(
ID NUMBER(5),
NAME CHAR(10),
ADDRESS VARCHAR2(50));
```



Q2) ID컬럼을 USR 컬럼으로 변경해보자

```sql
ALTER TABLE TEST
RENAME COLUMN ID TO USR;
```



Q3) TEST 테이블의 이름을 EXAM_TEST 테이블로 변경해보자.

```sql
ALTER TABLE TEST
RENAME TO EXAM_TEST;
```



Q4) EXAM_TEST 테이블을 삭제하고 휴지통을 비우자

```sql
CREATE TABLE TEST AS SELECT * FROM EXAM_TEST;

CREATE TABLE TEST01 AS SELECT * FROM EXAM_TEST;

DROP TABLE EXAM_TEST;

SELECT * FROM RECYCLEBIN; -- 휴지통 / 캐시메모리 버퍼 2K, 4K, 6K...
DESC RECYCLEBIN;

PURGE RECYCLEBIN; -- 휴지통 삭제
```



```markdown
캐시메모리(cache memory)
캐시 메모리는 마이크로프로세서가 일반적인 램에 비해 더 빨리 액세스 할 수 있는 램이다. 마이크로프로세서가 데이터를 처리할 때 제일 먼저 캐시 메모리에 있는지를 찾아본 후, 만약 거기에서 원하는 데이터를 찾으면, (읽는데 더 많은 시간이 필요한) 메인 메모리로 갈 필요가 없게 된다.

캐시 메모리는 때로 마이크로프로세서에 얼마나 가깝고, 접근하기 쉬우냐에 따라 두 단계로 나뉘어진다. 레벨-1 (흔히 L1이라고도 표기한다) 캐시는 마이크로프로세서와 같은 칩 내에 있다 (예를 들면 PowerPC 601 프로세서는 자체 칩 내에 32 KB의 L1 캐시가 내장되어 있다). 레벨-2 캐시는 보통 별도로 분리된 SRAM 칩이며, 메인 메모리는 보통 DRAM 칩을 사용한다. SRAM은 DRAM과는 달리 전자기적으로 재생시킬 필요가 없기 때문에 값이 더 비싸다. 많이 사용되는 캐시 메모리 크기는 1 MB 이다.

캐시 메모리 외에도, 많은 사람들이 램 그 자체도 하드디스크에 대해 캐시 메모리의 역할을 수행한다고 생각하는데, 그 이유는 사용자가 컴퓨터를 켜고 운영체계를 적재하면 일단 램의 모든 내용은 하드디스크로부터 가져오기 때문이며, 이후 사용자가 새로운 응용프로그램을 시작하는 바에 따라 새로운 데이터를 액세스하게 된다. 램은 하드디스크로부터 가장 최근에 읽었던 데이터를 유지하기 위해 디스크 캐시라고 불리는 특별한 장소를 가질 수 있다.
```



Q5) 휴지통에 넣지 않고 바로삭제하는 방법

```sql
DROP TABLE TEST01 PURGE;
```



```sql
INSERT INTO TEST VALUES(11,'111','111');

SELECT ROWID, USR, NAME, ADDRESS FROM TEST;
INSERT INTO TEST VALUES(112,'111','111');
INSERT INTO TEST VALUES(113,'111','111');

SELECT ROWID, USR, NAME, ADDRESS FROM TEST;
DELETE FROM TEST
WHERE USR = 113;

SELECT ROWID, USR, NAME, ADDRESS FROM TEST;
INSERT INTO TEST VALUES(111, '111', '111');
SELECT ROWID, USR, NAME, ADDRESS FROM TEST;

-- 통상 ROWID는 데이터 삭제 후에 테이블에 삭제 되기 전까지는 행의 식별자로 존재
-- 추가하면 다른 값으로 생성된다. C->D
```

























































